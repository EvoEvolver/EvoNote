from __future__ import annotations
import inspect
import re
from typing import Dict, List, Tuple, Callable, TYPE_CHECKING

if TYPE_CHECKING:
    from evonote.transform.module_to_notebook.extract_from_module import module_struct

Doc_parser_res = Tuple[str, Dict[str, str], str, List[str]]


def parse_reStructuredText_docs(raw_docs: str) -> Doc_parser_res:
    """
    Parse the docstring generated by PyCharm
    :param raw_docs: raw docstring
    :return: general, params, returns, keywords
    :keyword: parsing, docstring
    """
    state = "general"

    general = ""
    params = {}
    param_name = ""
    returns = ""
    keywords = []
    doc_lines = raw_docs.split("\n")
    for line in doc_lines:
        content_start = 0
        if line.startswith(":param"):
            # find next :
            next_colon = line.find(":", 6)
            if next_colon != -1:
                param_name = line[6:next_colon].strip()
                state = "param"
                content_start = next_colon + 1
        elif line.startswith(":return:"):
            state = "return"
            content_start = 8
        elif line.startswith(":keyword:"):
            state = "keyword"
            content_start = 9

        content = line[content_start:]
        if state == "param":
            params[param_name] = params.get(param_name, "") + content.strip()
        elif state == "return":
            returns += content.strip()
        elif state == "keyword":
            keywords.extend(content.strip().split(","))
        else:
            general += content.strip()
    return general, params, returns, keywords


def parse_google_docs(raw_docs: str):
    """
    Parse the docstring generated by VSCode
    :param raw_docs:
    :return:
    """
    state = "general"
    general = ""
    params = {}
    param_name = ""
    returns = ""
    doc_lines = raw_docs.split("\n")
    for line in doc_lines:
        content_start = 0
        if line.startswith("Args:"):
            state = "param"
            content_start = 5
            continue
        elif line.startswith("Returns:"):
            state = "return"
            content_start = 8

        content = line[content_start:]
        if state == "param":
            # find next :
            next_colon = line.find(":")
            new_content = line
            if next_colon != -1:
                param_name = line[:next_colon].strip()
                state = "param"
                content_start = next_colon + 1
                new_content = line[content_start:]
            params[param_name] = params.get(param_name, "") + " " + new_content.strip()
        elif state == "return":
            returns += content.strip()
        else:
            general += content.strip()
    return general, params, returns


class FunctionDocs:
    def __init__(self, general: str, params: Dict[str, str], returns: str,
                 keywords: List[str]):
        self.general: str = general if general is not None else ""
        self.params: Dict[str, str] = params if params is not None else {}
        self.returns: str = returns if returns is not None else ""
        self.keywords: List[str] = keywords if keywords is not None else []


Doc_parser = Callable[[str], Doc_parser_res]


def add_func_cls_to_struct_list(struct_list: List[module_struct], func_cls_list,
                                line_start_pos, struct_type):
    for func_cls in func_cls_list:
        struct_src, struct_start_line = inspect.getsourcelines(func_cls)
        struct_start_line -= 1
        struct_end_line = struct_start_line + len(struct_src)
        start_pos = line_start_pos[struct_start_line]
        end_pos = line_start_pos[struct_end_line]
        struct_list.append((struct_type, func_cls, (start_pos, end_pos)))


def prepare_func_cls_struct(functions, classes, module_src) -> List[module_struct]:
    """
    Transform the functions and classes into a list of module_struct
    :param functions: The functions in the module
    :param classes: The classes in the module
    :return: A list of module_struct sorted by the start line
    """
    src_lines = module_src.split("\n")
    line_start_pos = [0]
    for i in range(1, len(src_lines)):
        line_start_pos.append(line_start_pos[-1] + len(src_lines[i - 1]) + 1)

    structs = []
    add_func_cls_to_struct_list(structs, functions, line_start_pos, "function")
    add_func_cls_to_struct_list(structs, classes, line_start_pos, "class")
    structs.sort(key=lambda x: x[2][0])
    return structs


three_quote_pattern = re.compile(r'"""(.*?)"""', re.DOTALL)


def prepare_comment_struct(module_src: str) -> List[module_struct]:
    comment_struct_list = []
    matches = three_quote_pattern.finditer(module_src)
    for match in matches:
        comment_struct_list.append(("comment", match.group(1), match.span()))
    return comment_struct_list


def mix_cmt_cls_func_structs(cmt_structs, cls_func_structs) -> List[module_struct]:
    """
    Mix the comment_structs and cls_func_structs into a list of struct
    Discard the comments inside functions and classes
    :param cmt_structs: The comment_structs
    :param cls_func_structs: The cls_func_structs
    :return: A list of struct sorted by the start line
    """
    structs = []
    cmt_index = 0
    cls_func_index = 0
    while cmt_index < len(cmt_structs) and cls_func_index < len(cls_func_structs):
        cmt_struct = cmt_structs[cmt_index]
        cls_func_struct = cls_func_structs[cls_func_index]
        if cmt_struct[2][0] < cls_func_struct[2][0]:
            structs.append(cmt_struct)
            cmt_index += 1
        else:
            structs.append(cls_func_struct)
            cls_func_index += 1
            # discard the comments inside functions and classes
            if cmt_struct[2][1] < cls_func_struct[2][1]:
                cmt_index += 1
    # append the remaining structs
    # append the remaining comment_structs
    if (len(structs) > 0 and cmt_index < len(cmt_structs)
            and cmt_structs[-1][2][1] > structs[-1][2][1]):
        structs.extend(cmt_structs[cmt_index:])

    if cls_func_index < len(cls_func_structs):
        structs.extend(cls_func_structs[cls_func_index:])
    return structs


def get_in_module_structs(module, functions, classes) -> List[module_struct]:
    module_src = inspect.getsource(module)

    comment_struct_list = prepare_comment_struct(module_src)

    func_cls_structs = prepare_func_cls_struct(functions, classes, module_src)

    structs = mix_cmt_cls_func_structs(comment_struct_list, func_cls_structs)

    return structs
